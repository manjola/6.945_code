;;Author: Manushaqe Muco 
;;January 2017
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;Problem 1

;(modulo 13 8) ;5
;(remainder 13 8) ;5
;(modulo -13 8) ; 3
;(remainder -13 8) ;-5
;(modulo -13 -8) ;-5
;(remainder -13 -8) ;-5

;;Difference between "remainder" and "modulo".
; -13 = 8*a + b 
;remainder carries the normal division with n=8, giving us back what remains. In our case, -13 = 8(-1) + (-5)
;modulo gives us b in the range [0,n-1] if n>0 or [n-1, 0] if n<0. In our case [0,7], -13 = 8*(-2) + 3 
;modulo is best for our purposes. 

(define +mod
	(lambda (a b n) (modulo (+ a b) n)))

(define -mod
	(lambda (a b n) (modulo (- a b) n)))

(define *mod
	(lambda (a b n) (modulo (* a b) n)))

;(+mod 7 5 8)     ; -> 4
;(+mod 10 10 3)   ; -> 2
;(-mod 5 12 2)    ; -> 1
;(*mod 6 6 9)     ; -> 0
;(+mod 99 99 100) ; -> 98
;(*mod 50 -3 100) ; -> 50


(define modular
  (lambda (modulus op)
    (lambda (a1 a2)
      (modulo (op a1 a2) modulus))))

;((modular 17 +) 13 11)   ; -> 7
;((modular 17 -) 13 11)   ; -> 2
;((modular 17 *) 13 11)   ; -> 7

;;Problem 2

;slow-exptmod: linear recursive algorithm
;Order of growth in time: O(n)
;order of growth in space: O(n)

;exptomod: recursive algorithm
;Order of growth in time: O(log n)
;order of growth in space: O(log n)

(define (exptmod p)
  (let ((mod* (modular p *)))
    (define (square x)
     (mod* x x))
    (define (em base exponent)
      (cond ((= exponent 0) 1)
           ((even? exponent) (square (em base (/ exponent 2))))
	   (else (mod* base (em base (- exponent 1))))))
    em))

;((exptmod 10) 2 0)   ; -> 1
;((exptmod 10) 2 3)   ; -> 8
;((exptmod 10) 3 4)   ; -> 1
;((exptmod 100) 2 15) ; -> 68
;((exptmod 100) -5 3) ; -> 75

;;Problem 3 

(define (random-k-digit-number k)
 (if (= k 1) (random 10)
     (+ (* 10 (random-k-digit-number (- k 1))) (random 10))))

;(random-k-digit-number 1)  ; -> 5       (1 digit)
;(random-k-digit-number 3)  ; -> 980      (1-3 digits)
;(random-k-digit-number 3)  ; -> 513      (is it different?)
;(random-k-digit-number 50) ; -> 85583720100999182912992292931534079584236803744659


(define (count-digits n)
 (let ((quot (/ n 10))) 
   (if (< quot 1) 1
       (+ 1 (count-digits quot)))))

;(count-digits 3)         ; -> 1
;(count-digits 2007)      ; -> 4
;(count-digits 123456789) ; -> 9


(define (big-random n)
  (let ((result (random-k-digit-number (count-digits n))))
    (if (< result n) result
	(big-random n))))

;(big-random 100)          ; -> 9  (1-2 digit number)
;(big-random 100)          ; -> 68  (is it different?)
;(big-random 1)            ; -> 0
;(big-random 1)            ; -> 0     (should be always 0)
;(big-random (expt 10 40)) ; -> 973457158013760053934708467547325560780

;;Problem 4

;slow-prime?: iterative algorithm
;order of growth in time: O(n)
;order of growth in space: O(1)

;optimization 1: order of growth in time becomes O(sqrt n)
;optimization 2: will take half as much time, but linear still O(n)

;Fermat Test
(define (test a p)
  (= (modulo a p) ((exptmod p) a p)))

;(test 3 5) -> #t
;(test 3 6) -> #t (fails for composite)

(define prime-test-iterations 20)

(define prime?
  (lambda (p)
   (define (iter i)
     (if (= i prime-test-iterations) #t
	 (let ((a (big-random p)))
	   (if (test a p) (iter (+ i 1))
			   #f))))
   (iter 1)))
     

(prime? 2) ; -> #t
(prime? 4) ; -> #f
(prime? 1) ; -> #f
;(prime? 0) ; -> #f
;(prime? 200) ; -> ?
;(prime? 199) ; -> ?
