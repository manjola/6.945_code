;;; 6.945 Problem Set 1
;;; 
;;; Manushaqe Muco
;;; manjola@mit.edu

(load "~/6.945/6.945_code/ps01/regexp.scm")


;Problem 1.1
(define (r:* expr)
 ;0 or more copies
   (r:repeat 0 #f expr))

(define (r:+ expr)
 ;1 or more times
   (r:repeat 1 #f expr))

(define r:test-cases
  ;; Test cases for regular expressions, represented as 3-tuples where
  ;; the first item is the regular expression, the second is a test
  ;; string, and the last item is whether the expression should match
  ;; to the string or not.
  ;; These are a mixture of tests from the Perl unit tests, the
  ;; problem set examples, and my own invention.
  '(((r:quote "abc") "abc" #t)
    ((r:quote "abc") "xbc" #f)
    ((r:quote "abc") "abx" #f)
    ((r:quote "abc") "ababc" #t)
    ((r:quote ".?{|t+") ".?{|t+" #t) ; test BRE vs ERE quoting
    ((r:quote ".?{|t+") "a{" #f)
    ((r:quote ".?{|t+") "ttt" #f)
    ((r:repeat 0 #f (r:seq (r:alt (r:quote "cat") (r:quote "dog"))
			   (r:quote "qux"))) "dogquxdogqux" #t)
    ((r:seq (r:quote "cat") (r:repeat 0 #f (r:quote "dog")) (r:quote "qux")) "catdogqux" #t)
    ((r:seq (r:quote "cat") (r:repeat 0 #f (r:quote "dog")) (r:quote "dogqux")) "catdogqux" #t)
    ((r:seq (r:quote "cat") (r:repeat 1 #f (r:quote "dog")) (r:quote "dogqux")) "catdogdogqux" #t)
    ((r:seq (r:quote "cat") (r:repeat 1 #f (r:quote "dog")) (r:quote "dogqux")) "catdogcar" #f)
    ((r:seq (r:bol) (r:quote "abc") (r:eol)) "abc" #t)
    ((r:seq (r:bol) (r:quote "abc") (r:eol)) "aabc" #f)
    ((r:bol) "abc" #t)
    ((r:eol) "abc" #t)
    ((r:seq (r:quote "a") (r:dot) (r:quote "c")) "abc" #t)
    ((r:seq (r:quote "a") (r:dot) (r:quote "c")) "axc" #t)
    ((r:seq (r:quote "a") (r:repeat 0 #f (r:dot)) (r:quote "c")) "ac" #t)
    ((r:seq (r:quote "a") (r:char-from "bc") (r:quote "d")) "abc" #f)
    ((r:seq (r:quote "a") (r:char-from "bc") (r:quote "d")) "acd" #t)
    ((r:seq (r:quote "a") (r:char-from "bcd") (r:quote "e")) "ace" #t)
    ((r:seq (r:quote "a") (r:char-from "-b")) "a-" #t)
    ((r:seq (r:quote "a") (r:char-from "]") (r:quote "b")) "a]b" #t)
    ((r:seq (r:quote "a") (r:char-not-from "bc") (r:quote "d")) "aed" #t)
    ((r:seq (r:quote "a") (r:char-not-from "bc") (r:quote "d")) "abd" #f)
    ((r:seq (r:quote "a") (r:char-not-from "-bc") (r:quote "d")) "a-c" #f)
    ((r:seq (r:eol) (r:quote "b")) "b" #f)
    ((r:seq (r:quote "a") (r:* (r:quote "b")) (r:quote "bc")) "abbbbc" #t)
    ((r:seq (r:quote "a") (r:repeat 4 5 (r:quote "b")) (r:quote "bc")) "abbbbc" #f)
    ((r:seq (r:quote "a") (r:alt (r:quote "b") (r:quote "c")) (r:quote
							       "d")) "abd" #t)
    ((r:seq (r:quote "a") (r:alt (r:quote "b") (r:quote "c")) (r:quote
                                                               "d")) "aed" #f)
    ((r:* (r:alt (r:+ (r:quote "a")) (r:quote "b"))) "ab" #t)
    ((r:+ (r:alt (r:+ (r:quote "a")) (r:quote "b"))) "aaaa" #t)
    ((r:* (r:char-not-from "ab")) "cde" #t)
    ((r:seq (r:alt (r:quote "a") (r:quote "b") (r:quote "c") 
		   (r:quote "d") (r:quote "e")) (r:quote "f")) "ef" #t)
    ((r:seq (r:quote "a") (r:* (r:char-from "bc"))
	    (r:* (r:quote "c"))) "abc" #t)
    ((let ((digit
	    (r:char-from "0123456789")))
       (r:seq (r:bol)
	      (r:quote "[")
	      digit
	      digit
	      (r:quote "]")
	      (r:quote ".")
	      (r:quote " ")
	      (r:char-from "ab")
	      (r:repeat 3 5 (r:alt (r:quote "cat") (r:quote "dog")))
	      (r:char-not-from "def")
	      (r:eol))) "[09]. acatdogdogcats" #t)
    ((let ((digit
	    (r:char-from "0123456789")))
       (r:seq (r:bol)
	      (r:quote "[")
	      digit
	      digit
	      (r:quote "]")
	      (r:quote ".")
	      (r:quote " ")
	      (r:char-from "ab")
	      (r:repeat 3 5 (r:alt (r:quote "cat") (r:quote "dog")))
	      (r:char-not-from "def")
	      (r:eol))) "[10]. ifacatdogdogs" #f)
    ((let ((digit
	    (r:char-from "0123456789")))
       (r:seq (r:bol)
	      (r:quote "[")
	      digit
	      digit
	      (r:quote "]")
	      (r:quote ".")
	      (r:quote " ")
	      (r:char-from "ab")
	      (r:repeat 3 5 (r:alt (r:quote "cat") (r:quote "dog")))
	      (r:char-not-from "def")
	      (r:eol))) "[11]. ifacatdogdogsme" #f)
    ))

(define (eval-regexp quoted-expression)
  (eval quoted-expression user-initial-environment))

(define (r:run-tests test-cases grep-proc eval-proc)
  ;; Test the regular expressions for the given test cases, printing
  ;; out cases where they fail, and printing nothing if all tests
  ;; succeed.
  ;; Arguments:
  ;;    test-cases: List of 3-tuple test cases,
  ;;    grep-proc: The procedure to grep with, i.e. r:grep or r:egrep
  ;;    eval-proc: The procedure to evaluate and compile the quoted
  ;;    Scheme regular expression in the test case.
  ;;
  (define temp-filename "tmptests.txt")
  
  (define (write-to-file filename string)
    (let ((outport (open-output-file filename)))
      (display string outport)
      (newline outport)
      (close-output-port outport)))

  (define (run-test test-case)
    (let ((test-string (cadr test-case))
	  (test-query (car test-case)))
      (begin
	(write-to-file temp-filename test-string)
	(grep-proc (eval-proc test-query) temp-filename))))

  (define (test-case-correct? result test-case)
    (let ((expected-result (caddr test-case)))
      (if (not expected-result)
	  (not result)
	  (not (not result)))))

  (define (check-test-case test-case)
    (let ((result (run-test test-case)))
      (if (test-case-correct? result test-case)
	  #t
	  (begin
	    (display "******************* Test failed *****************")
	    (newline)
	    (display "Case: ") (display test-case)
	    (newline)
	    #f))))

  (define (all lst)
    (reduce (lambda (x y) (and x y)) #t lst))
  
  (all (map check-test-case test-cases)))

;#| Tests

(r:run-tests r:test-cases r:grep eval-regexp)
;Value: #t



;Problem 1.2

;a) If we try to evaluate (r:repeat 0 1 expr), we'll be stuck in a loop. 
;   We'll need to evaluate (r:repeat 0 1 expr) to evaluate (r:repeat 0 1 expr)

;b) Advantages:
;   (1) Code is more clear and modular. r:? can be reused elsewhere. 
;   (2) The regular expression produced will be shorter. We don't want a regular expression so big 
;   that the shell cannot evaluate it, for big max or min values. 

;c) Ben's proposal advantages:
;   (1) Shorter expression. For Bonnie's case your epression gets longer each time you have to match a character more than 1 times. 
;   In Ben's case it's more concise in specifying how many times you need to match the given character and shorter too. 
;   (2) Uses built-in machinery for BREs (grep utility built-ins), so it will run faster.
;   (3) Because it is used in BRE, it will be available for both BRE and ERE systems. ? could be available only to EREs. 


(define (r:repeat min max expr)
	(apply r:seq (list expr "\\{" (if min (number->string min) "") "," 		
			 (if max (number->string max) "") "\\}"))) 

(define (r:repeat-n-times n expr)
  (r:repeat n n expr))


;#| Tests

(define r:test-cases
  (append r:test-cases
	  '(((r:seq (r:bol) (r:repeat-n-times 3 (r:quote "cat")) (r:eol)) "catcatcat" #t)
	    ((r:seq (r:bol) (r:repeat-n-times 3 (r:quote "cat")) (r:eol)) "catcat" #f)
	    ((r:seq (r:bol) (r:repeat-n-times 3 (r:quote "cat")) (r:eol)) "catcatcatcat" #f))))

(r:run-tests r:test-cases r:grep eval-regexp)
;Value: #t


;Problem 1.3

(define (r:dot) (list 'dot))
(define (r:bol) (list 'bol))
(define (r:eol) (list 'eol))

(define (r:quote string)
  (list 'quote-string string))

(define (r:char-from string)
  (list 'char-from string))

(define (r:char-not-from string)
  (list 'char-not-from string))

(define (r:seq . exprs)  
  (define (capture-if-needed expr)
    (if (eq? (car expr) 'alt) ; If an alt is inside a sequence, then
			      ; it needs to be grouped, which in BREs
			      ; and EREs implies capturing.
	(r:capture expr)
	expr))
  (cons 'seq (map capture-if-needed exprs)))

(define (r:capture group)
  (list 'capture group))

(define (r:alt . exprs) ; This will only be grouped/captured when it
			; is embedded in a seq. If I group/capture it
			; here, then we might end up capturing it twice.
   (cons 'alt exprs))

(define (unit? expr)
  ;; Determine whether expr is a unit: a captured group, a bracket
  ;; expression, an anchor, an interval expression, 
  (let ((expr-tag (car expr)))
    (or (eq? expr-tag 'capture) 
	(eq? expr-tag 'char-from)
	(eq? expr-tag 'char-not-from)
	(eq? expr-tag 'bol)
	(eq? expr-tag 'eol)
	(eq? expr-tag 'dot)
	(eq? expr-tag 'backref)
	(and (eq? expr-tag 'quote-string)
	     (eq? (string-length (cadr expr)) 1)))))

(define (r:repeat min max expr) ; Only capture/group if the thing
				; repeated is more than one character
				; or not already grouped.
  (let ((expr (if (unit? expr)
		  expr
		  (r:capture expr))))
    (list 'repeat min max expr)))

(define (r:repeat-n-times n expr) ; Let's reuse r:repeat as much as
				  ; possible so we don't have to
				  ; repeat ourselves; also by not
				  ; using * and +, we avoid having to
				  ; escape them or not.
  (r:repeat n n expr))

(define (r:* expr)
  (r:repeat 0 #f expr))

(define (r:+ expr)
  (r:repeat 1 #f expr))


;;; Now we define how to compile these expressions to BREs by defining
;;; procedures seq, capture, etc., which produce strings. This means
;;; that the expression passed to r:grep and its ilk has to be first
;;; compiled into a BRE string using (r:compile).


(define (dot) ".")
(define (bol) "^")
(define (eol) "$")

(define (quote-string string)
  (list->string
   (append-map (lambda (char)
		 (if (memv char chars-needing-quoting)
		     (list #\\ char)
		     (list char)))
	       (string->list string))))

(define (char-from string)
  (case (string-length string)
    ((0) "")
    ((1) (quote-string string))
    (else
     (bracket string
              (lambda (members)
                (if (lset= eqv? '(#\- #\^) members)
                    '(#\- #\^)
                    (quote-bracketed-contents members)))))))

(define (char-not-from string)
  (bracket string
           (lambda (members)
             (cons #\^ (quote-bracketed-contents members)))))

(define (alt . exprs)
  (if (pair? exprs)
      (apply string-append
	     (cons (car exprs)
		   (append-map (lambda (expr)
				 (list "\\|" expr))
			       (cdr exprs))))
      ""))

(define (repeat-n-times n expr)
  (string-append expr
                 "\\{"
                 (number->string n)
                 "\\}"))

(define (repeat min max expr)
  (define (number->string-if-true item)
    (if item
        (number->string item)
	""))
  (string-append expr
                 "\\{"
                 (number->string-if-true min)
                 ","
                 (number->string-if-true max)
                 "\\}"))

(define (seq . exprs)
  (apply string-append exprs))

(define (capture group)
  (string-append "\\(" group "\\)"))

(define (r:compile-bre expression)
  (eval expression user-initial-environment)) ; For now!

(define (eval-bre quoted-expression)
  (r:compile-bre (eval quoted-expression user-initial-environment)))

;#| Tests

(r:run-tests r:test-cases r:grep eval-bre)
;Value: #t



